:doc:`IoTAnalytics <../../iotanalytics>` / Client / batch_put_message

*****************
batch_put_message
*****************



.. py:method:: IoTAnalytics.Client.batch_put_message(**kwargs)

  

  Sends messages to a channel.

  

  See also: `AWS API Documentation <https://docs.aws.amazon.com/goto/WebAPI/iotanalytics-2017-11-27/BatchPutMessage>`_  


  **Request Syntax**
  ::

    response = client.batch_put_message(
        channelName='string',
        messages=[
            {
                'messageId': 'string',
                'payload': b'bytes'
            },
        ]
    )
    
  :type channelName: string
  :param channelName: **[REQUIRED]** 

    The name of the channel where the messages are sent.

    

  
  :type messages: list
  :param messages: **[REQUIRED]** 

    The list of messages to be sent. Each message has the format: { "messageId": "string", "payload": "string"}.

     

    The field names of message payloads (data) that you send to IoT Analytics:

     

    
    * Must contain only alphanumeric characters and undescores (_). No other special characters are allowed.
     
    * Must begin with an alphabetic character or single underscore (_).
     
    * Cannot contain hyphens (-).
     
    * In regular expression terms: "^[A-Za-z_]([A-Za-z0-9]*|[A-Za-z0-9][A-Za-z0-9_]*)$".
     
    * Cannot be more than 255 characters.
     
    * Are case insensitive. (Fields named foo and FOO in the same payload are considered duplicates.)
    

     

    For example, {"temp_01": 29} or {"_temp_01": 29} are valid, but {"temp-01": 29}, {"01_temp": 29} or {"__temp_01": 29} are invalid in message payloads.

    

  
    - *(dict) --* 

      Information about a message.

      

    
      - **messageId** *(string) --* **[REQUIRED]** 

        The ID you want to assign to the message. Each ``messageId`` must be unique within each batch sent.

        

      
      - **payload** *(bytes) --* **[REQUIRED]** 

        The payload of the message. This can be a JSON string or a base64-encoded string representing binary data, in which case you must decode it by means of a pipeline activity.

        

      
    

  
  :rtype: dict
  :returns: 
    
    **Response Syntax**

    
    ::

      {
          'batchPutMessageErrorEntries': [
              {
                  'messageId': 'string',
                  'errorCode': 'string',
                  'errorMessage': 'string'
              },
          ]
      }
      
    **Response Structure**

    

    - *(dict) --* 
      

      - **batchPutMessageErrorEntries** *(list) --* 

        A list of any errors encountered when sending the messages to the channel.

        
        

        - *(dict) --* 

          Contains informations about errors.

          
          

          - **messageId** *(string) --* 

            The ID of the message that caused the error. See the value corresponding to the ``messageId`` key in the message object.

            
          

          - **errorCode** *(string) --* 

            The code associated with the error.

            
          

          - **errorMessage** *(string) --* 

            The message associated with the error.

            
      
    
  
  **Exceptions**
  
  *   :py:class:`IoTAnalytics.Client.exceptions.ResourceNotFoundException`

  
  *   :py:class:`IoTAnalytics.Client.exceptions.InvalidRequestException`

  
  *   :py:class:`IoTAnalytics.Client.exceptions.InternalFailureException`

  
  *   :py:class:`IoTAnalytics.Client.exceptions.ServiceUnavailableException`

  
  *   :py:class:`IoTAnalytics.Client.exceptions.ThrottlingException`

  