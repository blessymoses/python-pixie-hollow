:doc:`KinesisVideoArchivedMedia <../../kinesis-video-archived-media>` / Client / get_clip

********
get_clip
********



.. py:method:: KinesisVideoArchivedMedia.Client.get_clip(**kwargs)

  

  Downloads an MP4 file (clip) containing the archived, on-demand media from the specified video stream over the specified time range.

   

  Both the StreamName and the StreamARN parameters are optional, but you must specify either the StreamName or the StreamARN when invoking this API operation.

   

  As a prerequisite to using GetCLip API, you must obtain an endpoint using ``GetDataEndpoint``, specifying GET_CLIP for  the ``APIName`` parameter.

   

  An Amazon Kinesis video stream has the following requirements for providing data through MP4:

   

  
  * The media must contain h.264 or h.265 encoded video and, optionally, AAC or G.711 encoded audio. Specifically, the codec ID of track 1 should be ``V_MPEG/ISO/AVC`` (for h.264) or V_MPEGH/ISO/HEVC (for H.265). Optionally, the codec ID of track 2 should be ``A_AAC`` (for AAC) or A_MS/ACM (for G.711).
   
  * Data retention must be greater than 0.
   
  * The video track of each fragment must contain codec private data in the Advanced Video Coding (AVC) for H.264 format and HEVC for H.265 format. For more information, see `MPEG-4 specification ISO/IEC 14496-15 <https://www.iso.org/standard/55980.html>`__. For information about adapting stream data to a given format, see `NAL Adaptation Flags <http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/producer-reference-nal.html>`__.
   
  * The audio track (if present) of each fragment must contain codec private data in the AAC format ( `AAC specification ISO/IEC 13818-7 <https://www.iso.org/standard/43345.html>`__) or the `MS Wave format <http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html>`__.
  

   

  You can monitor the amount of outgoing data by monitoring the ``GetClip.OutgoingBytes`` Amazon CloudWatch metric. For information about using CloudWatch to monitor Kinesis Video Streams, see `Monitoring Kinesis Video Streams <http://docs.aws.amazon.com/kinesisvideostreams/latest/dg/monitoring.html>`__. For pricing information, see `Amazon Kinesis Video Streams Pricing <https://aws.amazon.com/kinesis/video-streams/pricing/>`__ and `Amazon Web Services Pricing <https://aws.amazon.com/pricing/>`__. Charges for outgoing Amazon Web Services data apply.

  

  See also: `AWS API Documentation <https://docs.aws.amazon.com/goto/WebAPI/kinesis-video-archived-media-2017-09-30/GetClip>`_  


  **Request Syntax**
  ::

    response = client.get_clip(
        StreamName='string',
        StreamARN='string',
        ClipFragmentSelector={
            'FragmentSelectorType': 'PRODUCER_TIMESTAMP'|'SERVER_TIMESTAMP',
            'TimestampRange': {
                'StartTimestamp': datetime(2015, 1, 1),
                'EndTimestamp': datetime(2015, 1, 1)
            }
        }
    )
    
  :type StreamName: string
  :param StreamName: 

    The name of the stream for which to retrieve the media clip.

     

    You must specify either the StreamName or the StreamARN.

    

  
  :type StreamARN: string
  :param StreamARN: 

    The Amazon Resource Name (ARN) of the stream for which to retrieve the media clip.

     

    You must specify either the StreamName or the StreamARN.

    

  
  :type ClipFragmentSelector: dict
  :param ClipFragmentSelector: **[REQUIRED]** 

    The time range of the requested clip and the source of the timestamps.

    

  
    - **FragmentSelectorType** *(string) --* **[REQUIRED]** 

      The origin of the timestamps to use (Server or Producer).

      

    
    - **TimestampRange** *(dict) --* **[REQUIRED]** 

      The range of timestamps to return.

      

    
      - **StartTimestamp** *(datetime) --* **[REQUIRED]** 

        The starting timestamp in the range of timestamps for which to return fragments.

         

        Only fragments that start exactly at or after ``StartTimestamp`` are included in the session. Fragments that start before ``StartTimestamp`` and continue past it aren't included in the session. If ``FragmentSelectorType`` is ``SERVER_TIMESTAMP``, the ``StartTimestamp`` must be later than the stream head.

        

      
      - **EndTimestamp** *(datetime) --* **[REQUIRED]** 

        The end of the timestamp range for the requested media.

         

        This value must be within 24 hours of the specified ``StartTimestamp``, and it must be later than the ``StartTimestamp`` value. If ``FragmentSelectorType`` for the request is ``SERVER_TIMESTAMP``, this value must be in the past.

         

        This value is inclusive. The ``EndTimestamp`` is compared to the (starting) timestamp of the fragment. Fragments that start before the ``EndTimestamp`` value and continue past it are included in the session.

        

      
    
  
  
  :rtype: dict
  :returns: 
    
    **Response Syntax**

    
    ::

      {
          'ContentType': 'string',
          'Payload': StreamingBody()
      }
      
    **Response Structure**

    

    - *(dict) --* 
      

      - **ContentType** *(string) --* 

        The content type of the media in the requested clip.

        
      

      - **Payload** (:class:`.StreamingBody`) -- 

        Traditional MP4 file that contains the media clip from the specified video stream. The output will contain the first 100 MB or the first 200 fragments from the specified start timestamp. For more information, see `Kinesis Video Streams Limits <https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/limits.html>`__.

        
  
  **Exceptions**
  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.ResourceNotFoundException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.InvalidArgumentException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.ClientLimitExceededException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.NotAuthorizedException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.UnsupportedStreamMediaTypeException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.MissingCodecPrivateDataException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.InvalidCodecPrivateDataException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.InvalidMediaFrameException`

  
  *   :py:class:`KinesisVideoArchivedMedia.Client.exceptions.NoDataRetentionException`

  